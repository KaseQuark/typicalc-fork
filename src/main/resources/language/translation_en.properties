root.close=Close
root.save=Save
root.copied=LaTeX code copied to clipboard.
root.exampleButton=📂 Examples
root.selectTerm=Select Term:
root.selectAssumptions=Select Assumptions:
root.termLabel=Term
root.typeInfer=Type
root.operatingHelp=Help
root.inputSyntax=Input Syntax
root.inputSyntaxShort=Syntax
root.inferenceRules=Inference Rules
root.absRule=Abs rule
root.appRule=App rule
root.varRule=Var rule
root.constRule=Const rule
root.letRule=Let rule
root.absRuleLet=Abs rule with Let
root.varRuleLet=Var rule with Let
root.inputFieldPlaceholder=Enter term here. A '\\' is converted to '\u03BB'.
root.typeInputFieldPlaceholder=Enter type assumptions here. A '!' is converted to '∀'.
root.termExplanation=The following grammar specifies the structure of a valid term:
root.assExplanation=In the type assumption input field, type assumptions are separated by a comma \
(<span style="font-family: Arial Black">,</span>).<br> The variable and type of a type assumption are separated by a colon \
(<span style="font-family: Arial Black">:</span>).
root.typeExplanation=The following grammar specifies the syntax of a valid type:
root.typeAssumptions=Type Assumptions
root.typeAssumptionsHint=To apply the type assumptions to the current term, you need to press "Type".
root.addAssumption=Add Type Assumption
root.deleteAll=Delete All
root.variable=Variable
root.type=Type
root.title404=404 - Not Found
root.message404=Try /infer/<term> or type your favourite term into the input field.
root.drawer=Type Inference Rules Button
root.shortcuts=Shortcuts
root.inputField=Input Field
root.typeInferButton=Type Button
root.firstStepButton=First-Step Button
root.previousStepButton=Previous-Step Button
root.nextStepButton=Next-Step Button
root.lastStepButton=Last-Step Button
root.shareButton=Share Button
root.inferenceViewFeatures=Inference Tree And Unification
root.helpDrawer=Clicking on type inference rules button opens up a collection of all type inference \
rules. By clicking on the copy button the LaTeX code of the corresponding rule is copied to the clipboard. \
The window can be closed by pressing the type inference rules button again.
root.helpExample=Clicking on the button opens up the example dialog. After clicking on an example term a number of \
type assumptions show up. Selecting a set of type assumptions will insert the term and the type assumptions into their \
respective input fields and automatically start the type inference algorithm.
root.helpInputField=The input field allows the user to enter lambda terms with a maximum length of 1000 characters. \
The λ character can be inserted by either clicking the λ button or entering a backslash. \
By clicking on the info icon the grammar defining the valid input syntax is shown.
root.helpTypeAssumptions=The type assumption input field allows the user to enter any number of type assumptions. \
By clicking the icon symbol the grammar defining valid type assumptions is shown. If the same variable \
is contained in multiple type assumptions, only the first type assumption containing the variable is used for \
the algorithm. If the type of a type assumptions starts with a 't' followed by only digits, the type is automatically \
converted to a type variable.
root.helpTypeInferButton=Clicking on the type button starts the type inference algorithm for the current input. \
The longer the entered term the longer the time to display the type inference tree. With a slow computer or a \
very long term some patience will be required.
root.helpShortcuts=<kbd>Ctrl</kbd> + <kbd>\u2190</kbd> = First step<br>\
<kbd>\u2190</kbd> = Previous step<br>\
<kbd>\u2192</kbd> = Next step<br>\
<kbd>Ctrl</kbd> + <kbd>\u2192</kbd> = Last step<br>\
<kbd>/</kbd> = Focus input bar
root.helpFirstStepButton=The function of the button depends on the current state of the algorithm. \
If the tree is currently being built up, clicking on the button shows the first step of the inference tree. \
If the unification algorithm is already in progress, clicking on the button shows the last step of the inference \
tree. The key combination <kbd>Ctrl</kbd> + <kbd>\u2190</kbd> also executes a click on the button.
root.helpPreviousStepButton=By clicking the previous step button the previous step of the algorithm is shown. \
The key <kbd>\u2190</kbd> also executes a click on the button.
root.helpNextStepButton=By clicking the next-step button the next step of the algorithm is shown. \
The key  <kbd>\u2192</kbd> also executes a click on the button.
root.helpLastStepButton=The function of the button depends on the current state of the algorithm. \
If the tree is currently being built up, clicking on the button shows the last step of the inference tree. \
If the unification algorithm is already in progress, clicking on the button shows the final type of the  \
entered term. The key combination <kbd>Ctrl</kbd> + <kbd>\u2192</kbd> also executes a click on the button.
root.helpShareButton=Clicking the share button opens up a dialog containing the LaTeX code of the final inference \
tree and the packages needed to compile the LaTeX code. In addition a permalink to the current page is provided. \
This link encodes the current term as well as the current type assumptions.
root.helpInferenceViewFeatures=When a term is successfully type inferred, the inference tree and the unification are \
  displayed. To zoom in and out the inference tree, scroll with your mouse. To move the tree, drag it with your \
  pressed left mouse button. While the tree is building up, the resulting constraints build up simultaneously in the \
  field above. During the unification, the modified constraints are then highlighted in each step. \
  If the entered term contains let polymorphism, the constraints of the let sub-tree are unified before further \
  steps in the tree are shown. If such a sub-unification or the outermost unification fails, the whole algorithm is \
  cancelled. At the end, the most general unifier is displayed as \u03C3 and the final type as \u03C3(\u03B1\u2081).
help.typicalcInfo=\
<a href="https://git.scc.kit.edu/pse-typinferenz/typicalc">Typicalc</a> was developed as a PSE project at \
   the KIT in WS 20/21 by<br>\
  Robin Böhne<br>\
  Moritz Dieing<br>\
  Thomas Heinen<br>\
  Arne Keller<br>\
  Johanna Stuber
error.tooFewTokensHelp=unexpected end of input
root.UNEXPECTED_TOKEN=The input does not match the syntax specified in the info dialog.
root.UNEXPECTED_CHARACTER=The input contains a character which is not allowed at this position.
error.heading=Input is syntactically wrong!
error.wrongCharacter=Wrong character:\u0020
error.termForError=Term:\u0020
error.typeAssumptionForError=Type assumption:\u0020
error.expectedToken=Expected: %0%
error.additionalInformation = Information: %0%
error.hint=The grammars describing the correct syntax of a term or a type assumption can also be reached \
  via the info icon.
tokentype.UNIVERSAL_QUANTIFIER=universal quantifier
tokentype.LAMBDA=λ
tokentype.VARIABLE=variable
tokentype.LET=let
tokentype.IN=in
tokentype.TRUE=true
tokentype.FALSE=false
tokentype.NUMBER=number
tokentype.LEFT_PARENTHESIS=(
tokentype.RIGHT_PARENTHESIS=)
tokentype.DOT=.
tokentype.COMMA=,
tokentype.COLON=:
tokentype.EQUALS==
tokentype.ARROW=->
tokentype.EOF=End of input
additionalInformation.DUPLICATETYPE= Duplicate
expectedinput.VARTYPE= Variable of the form t[0-9]+
expectedinput.TERM=any lambda term
expectedinput.TYPE=any type
root.or=or
root.slideExp=Typicalc is an application for the visualisation of type inference. The slideshow below the text \
demonstrates the most important features of the website. In each slide the relevant operating element is surrounded \
by a red border. The buttons at the bottom of the website can be used to navigate through the slides.
root.linkText=Further information on the type inference algorithm can be found \u0020
root.link=https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
root.here=here
root.image0=/carousel/StartPage-english.jpg
root.text0=Use the buttons at the bottom of the page to navigate through the slideshow.
root.image1=/carousel/EnterTerm-english.jpg
root.text1=The term λx.x is entered into the input field.
root.image2=/carousel/OpenTypeAssumptions-english.jpg
root.text2=The type assumptions button is clicked to open up a dialog to enter type assumptions.
root.image3=/carousel/EnterTypeAssumptions-english.jpg
root.text3=A type assumption with variable "x" and type "int" is being entered.
root.image4=/carousel/ClickTypeButton-english.jpg
root.text4=The type button is clicked to start the type inference algorithm.
root.image5=/carousel/NavigateTree-english.jpg
root.text5=The buttons at the bottom of the website can be used to navigate through the steps of the algorithm.
root.image6=/carousel/EndOfTree-english.jpg
root.text6=At the end of the algorithm the most general unifier, the final type and the final tree of the \
entered term are being displayed.
root.image7=/carousel/ClickShareButton-english.jpg
root.text7=The share button is clicked to open up the corresponding dialog.
root.image8=/carousel/UseShareDialog-english.jpg
root.text8=The dialog contains a permalink to the current page, the LaTeX-code of the tree and the packages needed \
to compile the code.
root.correctAssumptions=Correct or delete the invalid type assumptions (red background) before closing the dialog.
root.copyLatexTooltip=Copy LaTeX code
root.helpIcon=Help
root.exampleTooltip=Example terms
root.shareButtonTooltip=LaTeX code and permalink
root.lastStepTooltip=Last step
root.firstStepTooltip=First step
root.previousStepTooltip=Previous step
root.nextStepTooltip=Next step
root.backButtonTooltip=Back
root.selectedTerm=Selected term

root.absLetLatex=\
\\begin{prooftree}\
\\AxiomC{$\\Gamma , \\texttt{x}: \\tau_1 \\vdash t : \\tau_2$}\
\
\\AxiomC{$\\tau_1$ \\ \\texttt{no type scheme}}\
\
\\LeftLabel{\\rm A{\\small BS}}\
\\BinaryInfC{$\\Gamma \\vdash \\lambda \\texttt{x}.t : \\tau_1 \\rightarrow \\tau_2$}\
\\end{prooftree}

root.infinite_type = The entered term cannot be typed: The highlighted constraint would cause an infinite type!
root.different_types = The entered term cannot be typed: The highlighted constraint contains two incompatible types!

share.heading=Share
share.url.label=URL
share.packagesTree.label=Packages (inference tree)
share.latexTree.label=LaTeX code (whole inference tree)
share.packagesUnification.label=Packages (unification/MGU)
share.latexUnification.label=LaTeX code (current step in unifcation/MGU)

explanationTree.initial=At the beginning of the algorithm the type variable %1% is assigned to the input %0%. \
 In the following steps the type of %1% will be determined gradually.
explanationTree.varStep=The current expression %0% is a variable. Therefore the var rule is applied to the variable \
 %0% of type %1%. Since %0% is of type %2% under the given type assumptions, the constraint %3% is added to the set \
 of constraints.
explanationTree.absStep=Since the current expression %0% is an abstraction of type %1% with parameter %2% and result %3%, \
 the abs rule is applied in this step. To do this, the parameter is assigned type %4% and the result is assigned type %5%. \
 Therefore the abstraction is of type %6% and the constraint %7% has to be added to the set of constraints.
explanationTree.appStep=Since the current expression %0% is an application of type %1% with function %2% and argument %3% \
 the app rule is applied in this step. To do this, the function is assigned type %4% and the argument is assigned type \
 %5%. Therefore the function is of the type %6% and the constraint %7% has to be added to the set of constraints.
explanationTree.constStep=The current expression %0% is a constant. Therefore the const rule is applied to the constant \
 %0% of type %1%. Since the value of %0% is %2%, the constraint %3% is added to the set of constraints.
explanationTree.letStep=Since the current expression %0% is a let-expression of type %1% with variable %2%, definition %3% \
 and inner term %4%, the let rule is applied in this step. To do this, a new type inference with expression %3% is started \
 in the left subtree. As the let-expression and the inner term have to be of the same type, the constraint %5% is added to \
 the set of constraints.
expUnification.initial=In the following steps the unfication algorithm will be executed on the set of constraints %0% to \
 determine the type of the initial input.
expLetUnification.initial=In the following steps the unfication algorithm will be executed on the set of constraints %0% \
 to determine the type of the let-variable %1%.
expUnification.trivial=In this step the constraint %0% has been removed. Since the left and right side of the constraint \
 are identical, the constraint is always fulfilled and hence is of no use.
expUnification.variable=In this step the constraint %0% has been replaced. Since %1% is a variable type and does not appear \
 in %2%, all other appearances of %1% can be replaced by %2%. To do this, the substitution %3% is created and is applied to \
 the remaining set of constraints. All changes of the set are highlighted in blue.
expUnification.function=In this step the constraint %0% has been replaced. Since %1% as well as %2% are function types, \
 the constraints %3% and %4% have to be added to the set of constraints. The original constraint %0% has been removed from \
 the set.
expUnification.mgu=In this step the most general unifier %0% for the set of constraints %1% is calculated. Therefore the \
 whole set of substitutions is applied to every single substitution of the set.
expUnification.finalType=In this step the most general unifier %0% is applied to the type %1% of the input. The result %2% \
 is the final type of the input.
expUnification.infiniteType=The same type variable appears on both sides of the constraint. Since this would cause an \
 infinite type, the execution of the unification is stopped.
expUnification.differentTypes=Since the types on both sides of the constraint are incompatible, the execution of the \
 unification is stopped.
expLetUnification.finalType=In this step the most general unifier %0% is applied to the type %1% of the let-definition. \
 The result %2% is the final type of the let-definition.
expLetUnification.typeAss=In this step the type assumptions %0% for the further execution of the algorithm are \
 calculated. To do this, %1% is applied to the current set of type assumptions. The resulting new type assumptions are \
 added to the set %0%. Afterwards the type of the let-variable %2% is calculated. Therefore the type assumption is \
 instantiated and then added to the set %0% as a type assumption with variable %2%.
expLetUnification.letStep=The let-inference is now finished. The execution of the algorithm continues with the newly \
 calculated type assumptions and the old set of constraints extended by the set %0%.