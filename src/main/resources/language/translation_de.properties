root.close=Schlie√üen
root.save=Speichern
root.copied=LaTeX-Code in Zwischenablage kopiert.
root.exampleButton=üìÇ Beispiele
root.selectTerm=Term ausw√§hlen:
root.selectAssumptions=Typannahmen ausw√§hlen:
root.termLabel=Term
root.typeInfer=Typisieren
root.operatingHelp=Hilfe
root.inputSyntax=Eingabe-Syntax
root.inputSyntaxShort=Syntax
root.inferenceRules=Ableitungsregeln
root.absRule=Abs-Regel
root.appRule=App-Regel
root.varRule=Var-Regel
root.constRule=Const-Regel
root.letRule=Let-Regel
root.inputFieldPlaceholder=Term hier eingeben. Ein '\\' wird zu '\u03BB' umgewandelt.
root.typeInputFieldPlaceholder=Typannahmen hier eingeben. Ein '!' wird zu '‚àÄ' umgewandelt.
root.absRuleLet=Abs-Regel mit Let
root.varRuleLet=Var-Regel mit Let
root.termExplanation=Die folgende Grammatik beschreibt den Aufbau eines g√ºltigen Terms:
root.assExplanation=Im Typannahmen-Eingabefeld werden einzelne Typannahmen durch ein Komma \
(<span style="font-family: Arial Black">,</span>)<br>voneinander getrennt. Variable und Typ einer Typannahme werden \
durch einen<br>Doppelpunkt (<span style="font-family: Arial Black">:</span>) separiert.
root.typeExplanation=Die folgende Grammatik beschreibt die Syntax eines g√ºltigen Typs:
root.typeAssumptions=Typannahmen
root.typeAssumptionsHint=Um die Typannahmen auf den Term anzuwenden, muss neu typisiert werden.
root.addAssumption=Typannahme hinzuf√ºgen
root.deleteAll=Alle l√∂schen
root.variable=Variable
root.type=Typ
root.title404=404 - Seite nicht gefunden
root.message404=Versuche /infer/<term> oder gib deinen Lieblingsterm in das Eingabefeld ein.
root.drawer=Ableitungsregeln-Knopf
root.shortcuts=Tastaturbefehle
root.inputField=Eingabefeld
root.typeInferButton=Typisieren-Knopf
root.firstStepButton=Erster-Schritt-Knopf
root.previousStepButton=Vorheriger-Schritt-Knopf
root.nextStepButton=N√§chster-Schritt-Knopf
root.lastStepButton=Letzter-Schritt-Knopf
root.shareButton=Teilen-Knopf
root.inferenceViewFeatures=Typherleitungsbaum und Unifikation
root.helpDrawer=Durch Benutzen des Ableitungsregeln-Knopfs √∂ffnet sich eine \
eine Auflistung aller Typinferenzregeln. \
Mit Hilfe des Kopieren-Knopfs kann der Latex-Code der jeweiligen Regel in die Zwischenablage kopiert werden. \
Durch Bet√§tigen des Ableitungsregeln-Knopfs wird das Fenster wieder geschlossen.
root.helpExample=Durch Benutzen des Knopfs √∂ffnet sich der Beispiel-Dialog. \
Nach Anklicken eines Beispielterms wird eine Reihe von Typannahmen angezeigt. \
Mit dem Ausw√§hlen einer Menge von Typannahmen werden der Beispielterm und die Typannahmen in ihr jewiliges \
Eingabefeld eigef√ºgt. Anschlie√üend startet direkt der Typinferenzalgorithmus.
root.helpInputField=In das Eingabefeld k√∂nnen Lambda-Terme mit einer L√§nge von bis zu 1000 Zeichen eingegeben werden. \
Das Œª-Zeichen kann dabei entweder durch Klicken des Œª-Knopfs oder durch Eingabe eines Backslashs \
eingef√ºgt werden. Durch Klicken des Info-Symbols wird die korrekte Syntax eines Terms \
angezeigt.
root.helpTypeAssumptions=In das Typannahmen-Eingabefeld kann eine beliebige Anzahl an Typannahmen eingegeben werden. \
Durch Klicken des Info-Symbols wird die korrekte Syntax der Typannahmen angezeigt. Sofern eine Variable in \
mehreren Typannahmen vorkommt, wird ausschlie√ülich die erste Typannahme, die diese Variable enth√§lt, \
ber√ºcksichtigt. Falls der Typ einer Typannahme mit einem 't' beginnt und anschlie√üend nur Ziffern folgen, wird der Typ \
automatisch zu einer Typvariable.
root.helpTypeInferButton=Durch Benutzen des Typisieren-Knopfs wird die Berechnung des Typinferenzalgorithmus mit \
der aktuellen Eingabe gestartet. Je gr√∂√üer der Term desto l√§nger dauert das Anzeigen des Typherleitungsbaums. Bei sehr \
gro√üer Eingabe oder einem langsamen Rechner wird also etwas Geduld ben√∂tigt.
root.helpShortcuts=<kbd>Strg</kbd> + <kbd>\u2190</kbd> = Erster Schritt<br>\
<kbd>\u2190</kbd> = Vorheriger Schritt<br>\
<kbd>\u2192</kbd> = N√§chster Schritt<br>\
<kbd>Strg</kbd> + <kbd>\u2192</kbd> = Letzter Schritt<br>\
<kbd>/</kbd> = Fokus auf Eingabefeld
root.helpFirstStepButton=Je nach Stand der Algorithmusausf√ºhrung √§ndert sich die Funktion des Knopfs. \
Wenn aktuell der Baum aufgebaut wird, springt die Anzeige nach Benutzen des Knopfs zur√ºck zum ersten Schritt des \
Typherleitungsbaums. Wenn bereits die Unifikation durchgef√ºhrt wird, springt die Anzeige nach Benutzen des Knopfs \
in den letzten Schritt des Baums. Der Knopf l√§sst sich au√üerdem durch die Tastenkombination <kbd>Strg</kbd> +\
<kbd>\u2190</kbd> ansprechen.
root.helpPreviousStepButton=Durch Benutzen des Vorheriger-Schritt-Knopfs wird der vorherige Schritt des Algorithmus \
angezeigt. Der Knopf l√§sst sich au√üerdem auf der Tastatur durch die Taste <kbd>\u2190</kbd> ansprechen.
root.helpNextStepButton=Durch Benutzen des N√§chster-Schritt-Knopfs wird der n√§chste Schritt des Algorithmus angezeigt. \
Der Knopf l√§sst sich au√üerdem durch auf der Tastatur durch die Taste <kbd>\u2192</kbd> ansprechen.
root.helpLastStepButton=Je nach Stand der Algorithmusausf√ºhrung √§ndert sich die Funktion des Knopfs. \
Wenn aktuell der Baum aufgebaut wird, springt die Anzeige nach Klicken des Knopfs vor zum letzten Schritt des \
Typherleitungsbaums. Wenn bereits die Unifikation durchgef√ºhrt wird, springt die Anzeige nach Klicken des Knopfs \
vor zur Anzeige des finalen Typs. Der Knopf l√§sst sich au√üerdem durch die Tastenkombination \
<kbd>Strg</kbd> + <kbd>\u2192</kbd> ansprechen.
root.helpShareButton=Durch Benutzen des Teilen-Knopfs √∂ffnet sich ein Dialog, in dem der LaTeX-Code des finalen \
Typherleitungsbaums des eingegebenen Terms und die ben√∂tigen Pakete zum Einbinden des LaTeX-Codes angezeigt werden. \
Zus√§tzlich dazu enth√§lt der Dialog einen Permalink zur aktuellen Seite, der sowohl den Term als auch die Typannahmen \
kodiert.
root.helpInferenceViewFeatures=Wurde ein Term erfolgreich typisiert, werden der Typherleitungsbaum und die \
  Unifikation angezeigt. Der Baum l√§sst sich durch Scrollen mit der Maus vergr√∂√üern und verkleinern und durch Halten \
  und Ziehen mit der linken Maustaste verschieben. Die Constraints bauen sich parallel zum Baum im Feld dar√ºber auf. \
  Bei der Unifikation werden dann die sich ver√§ndernden Stellen in den Constraints in jedem Schritt farblich \
  hervorgehoben. Kommt im eingegebenen Term let-Polymorphismus vor, wird im Constraint-Feld zun√§chst \
  die Unifikation der Constraints vom let-Teilbaum durchgef√ºhrt, bevor der Baum weiter aufgebaut wird. \
  Schl√§gt solch eine Teilunifikation oder auch die √§u√üerste Unifikation fehl, wird der gesamte Algorithmus \
  abgebrochen. Mit \u03C3 wird am Ende der allgemeinste Unifikator angegeben, mit \u03C3(\u03B1\u2081) der \
  finale Typ des Terms.
help.typicalcInfo=\
<a href="https://git.scc.kit.edu/pse-typinferenz/typicalc">Typicalc</a> wurde als PSE-Projekt am KIT im WS 20/21 \
  entwickelt von<br>\
  Robin B√∂hne<br>\
  Moritz Dieing<br>\
  Thomas Heinen<br>\
  Arne Keller<br>\
  Johanna Stuber<br>
error.tooFewTokensHelp=unerwartetes Ende der Eingabe
root.UNEXPECTED_TOKEN=Die Eingabe entspricht nicht der im Info-Dialog spezifizierten Syntax!
root.UNEXPECTED_CHARACTER=Die Eingabe enth√§lt ein Zeichen, welches an dieser Stelle nicht erlaubt ist!
error.heading=Syntaktisch falsche Eingabe!
error.termForError=Term:\u0020
error.typeAssumptionForError=Typannahme:\u0020
error.wrongCharacter=Falsches Zeichen:\u0020
error.expectedToken=Erwartet: %0%
error.additionalInformation = Information: %0%
error.hint=Die Grammatiken, die die korrekte Syntax eines Terms und der Typannahmen beschreiben, \
  sind auch √ºber das Info-Symbol zu erreichen.
tokentype.UNIVERSAL_QUANTIFIER=Allquantor
tokentype.LAMBDA=Œª
tokentype.VARIABLE=Variable
tokentype.LET=let
tokentype.IN=in
tokentype.TRUE=true
tokentype.FALSE=false
tokentype.NUMBER=Zahl
tokentype.LEFT_PARENTHESIS=(
tokentype.RIGHT_PARENTHESIS=)
tokentype.DOT=.
tokentype.COMMA=,
tokentype.COLON=:
tokentype.EQUALS==
tokentype.ARROW=->
tokentype.EOF=Ende der Eingabe
expectedinput.VARTYPE= Variable der Form t[0-9]+
additionalInformation.DUPLICATETYPE= Duplikat
expectedinput.TERM=beliebiger Term
expectedinput.TYPE=beliebiger Typ
root.or=oder
root.slideExp=Typicalc ist eine Anwendung zur Visualisierung von Typinferenz. In der folgenden Slideshow wird ein \
Beispielszenario mit den wichtigsten Funktionen der Website vorgef√ºhrt. Das relevante Bedienelement ist jeweils mit \
einem roten Rahmen hervorgehoben. Zwischen einzelnen Slides kann mithilfe der Kn√∂pfe am unteren Ende der Seite \
navigiert werden.
root.linkText=Weitere Informationen zur Typinferenz findest du \u0020
root.link=https://de.wikipedia.org/wiki/Typinferenz_nach_Hindley-Milner
root.here=hier
root.image0=/carousel/StartPage-german.jpg
root.text0=Verwende die Kn√∂pfe am unteren Ende der Seite, um durch die Slideshow zu navigieren.
root.image1=/carousel/EnterTerm-german.jpg
root.text1=Der Term \u03BBx.x wird in das Textfeld eingegeben.
root.image2=/carousel/OpenTypeAssumptions-german.jpg
root.text2=Der Typannahmen-Knopf wird bet√§tigt, um ein Fenster zur Eingabe von Typannahmen zu √∂ffnen.
root.image3=/carousel/EnterTypeAssumptions-german.jpg
root.text3=Eine Typannahme mit Variable "x" und Typ "int" wird hinzugef√ºgt.
root.image4=/carousel/ClickTypeButton-german.jpg
root.text4=Der Typisieren-Knopf wird bet√§tigt, um den Typinferenzalgorithmus zu starten.
root.image5=/carousel/NavigateTree-german.jpg
root.text5=Die Kn√∂pfe am unteren Ende der Seite werden verwendet, um zwischen einzelnen Schritten des Algorithmus \
zu wechseln.
root.image6=/carousel/EndOfTree-german.jpg
root.text6=Am Ende des Algorithmus sind der allgemeinste Unifikator, der finale Typ und der finale Herleitungsbaum \
der Eingabe zu sehen.
root.image7=/carousel/ClickShareButton-german.jpg
root.text7=Der Teilen-Knopfs wird bet√§tigt, um das entsprechende Dialogfenster zu √∂ffnen.
root.image8=/carousel/UseShareDialog-german.jpg
root.text8=In dem Dialogfenster sind der Permalink zur aktuellen Seite, der Latex-Code des Baums und die im Code \
verwendeten Pakete aufgelistet.
root.correctAssumptions=Korrigiere oder l√∂sche die ung√ºltigen Typannahmen (rot hinterlegt) \
vor dem Schlie√üen des Dialogs.
root.copyLatexTooltip=Kopiere LaTeX-code
root.helpIcon=Hilfe
root.exampleTooltip=Beispielterme
root.shareButtonTooltip=LaTeX-Code und Permalink
root.lastStepTooltip=Letzter Schritt
root.firstStepTooltip=Erster Schritt
root.previousStepTooltip=Vorheriger Schritt
root.nextStepTooltip=N√§chster Schritt
root.backButtonTooltip=Zur√ºck
root.selectedTerm=Ausgew√§hlter Term

root.absLetLatex=\
\\begin{prooftree}\
\\AxiomC{$\\Gamma , \\texttt{x}: \\tau_1 \\vdash t : \\tau_2$}\
\
\\AxiomC{$\\tau_1$ \\ \\texttt{kein Typschema}}\
\
\\LeftLabel{\\rm A{\\small BS}}\
\\BinaryInfC{$\\Gamma \\vdash \\lambda \\texttt{x}.t : \\tau_1 \\rightarrow \\tau_2$}\
\\end{prooftree}

root.infinite_type = Der eingegebene Term ist nicht typisierbar: \
  Durch den {\\color{#f00}hervorgehobenen} Constraint w√ºrde sich ein unendlicher Typ ergeben!
root.different_types = Der eingegebene Term ist nicht typisierbar: \
  In dem {\\color{#f00}hervorgehobenen} Constraint werden zwei unvereinbare Typen gleichgesetzt!

share.heading=Teilen
share.url.label=URL
share.packagesTree.label=Pakete (Typherleitungsbaum)
share.latexTree.label=LaTeX-Code (vollst√§ndiger Typherleitungsbaum)
share.packagesUnification.label=Pakete (Unifikation/MGU)
share.latexUnification.label=LaTeX-Code (aktueller Schritt in Unifikation/MGU)

explanationTree.initial1=Zu Beginn der Typinferenz wird dem eingegebenen Term
explanationTree.initial2=die Typvariable
explanationTree.initial3=zugewiesen. In den folgenden Schritten wird der Typ von
explanationTree.initial4=sukzessive bestimmt.
explanationTree.varStep1=Der aktuelle Term
explanationTree.varStep2=ist eine Variable. Daher wird in diesem Schritt die Var-Regel auf die Variable
explanationTree.varStep3=vom Typ
explanationTree.varStep4=angewendet. Da
explanationTree.varStep5=unter der Typumgebung den Typen
explanationTree.varStep6=besitzt, wird die Bedingung
explanationTree.varStep7=der Constraintmenge hinzugef√ºgt.
explanationTree.absStep1=Da der aktuelle Term
explanationTree.absStep2=eine Abstraktion vom Typ
explanationTree.absStep3=mit Parameter
explanationTree.absStep4=und Ergebnis
explanationTree.absStep5=ist, wird in diesem Schritt die Abs-Regel angewendet. Daf√ºr wird dem Parameter der Typ
explanationTree.absStep6=und dem Ergebnis der Typ
explanationTree.absStep7=zugewiesen. Da die Abstraktion unter dieser zus√§tzlichen Annahme den Typ
explanationTree.absStep8=besitzt, muss die Bedingung
explanationTree.absStep9=der Constraintmenge hinzugef√ºgt werden.
explanationTree.appStep1=Da der aktuelle Term
explanationTree.appStep2=eine Applikation vom Typ
explanationTree.appStep3=mit Funktion
explanationTree.appStep4=und Argument
explanationTree.appStep5=ist, wird in diesem Schritt die App-Regel angewendet. Daf√ºr wird der Funktion der Typ
explanationTree.appStep6=und dem Argument der Typ
explanationTree.appStep7=zugewiesen. Da die Funktion unter dieser zus√§tzlichen Annahme den Typ
explanationTree.appStep8=besitzt, muss die Bedingung
explanationTree.appStep9=der Constraintmenge hinzugef√ºgt werden.
explanationTree.constStep1=Der aktuelle Term
explanationTree.constStep2=ist eine Konstante. Daher wird in diesem Schritt die Const-Regel auf die Konstante
explanationTree.constStep3=vom Typ
explanationTree.constStep4=angewendet. Da
explanationTree.constStep5=ein
explanationTree.constStep6=Wert ist, wird die Bedingung
explanationTree.constStep7=der Constraintmenge hinzugef√ºgt.
explanationTree.letStep1=Da der aktuelle Term
explanationTree.letStep2=ein Let-Ausdruck vom Typ
explanationTree.letStep3=mit Variable
explanationTree.letStep4=, Definition
explanationTree.letStep5=und innerem Term
explanationTree.letStep6=ist, wird in diesem Schritt die Let-Regel angewendet. Daf√ºr wird im linken Teilbaum eine neue \
Typinferenz mit dem Term
explanationTree.letStep7=gestartet. Mit dem Ergebnis der Let-Teilinferenz l√§sst sich anschlie√üend der Typ der Variable
explanationTree.letStep8=bestimmen. Da der Let-Ausdruck und der innere Term vom gleichen Typ sind, muss au√üerdem die \
Bedingung
explanationTree.letStep9=der Constraintmenge hinzugef√ºgt werden.

expUnification.initial1=In den folgenden Schritten wird der Unifikationsalgorithmus auf der Constraintmenge ausgef√ºhrt, \
um den Typen des eingegebenen Terms zu bestimmen.
expLetUnification.initial1=In den folgenden Schritten wird der Unifikationsalgorithmus auf der Constraintmenge \
ausgef√ºhrt, um den Typen der let-Variable zu finden und damit die neue Typumgebung zu bestimmen.
expUnification.trivial1=In diesem Schritt wurde der Constraint
expUnification.trivial2=entfernt. Da linke und rechte Seite identisch sind, ist der Constraint immer erf√ºllt und \
wird somit nicht ben√∂tigt.
expUnification.variable=In diesem Schritt wurde der Constraint %0% ersetzt.\
  Da %1% ein Variablentyp ist und nicht in %2% vorkommt, k√∂nnen alle Vorkommen von %1% durch %2% ersetzt werden.\
  In der Folge wird die Substitution %3% erstellt und auf die √ºbrige Constraintmenge angewandt.\
  Die daraus resultierenden Ver√§nderungen sind blau markiert.
expUnification.function1=In diesem Schritt wurde der Constraint
expUnification.function2=ersetzt. Da sowohl
expUnification.function3=als auch
expUnification.function4=Funktionstypen sind, m√ºssen die beiden Constraints
expUnification.function5=und
expUnification.function6=der Constraintmenge hinzugef√ºgt werden. Der urspr√ºngliche Constraint
expUnification.function7=wurde aus der Menge entfernt.
expUnification.mgu1=In diesem Schritt wird der allgemeinste Unifikator
expUnification.mgu2=der Constraintmenge
expUnification.mgu3=berechnet. Daf√ºr wird die gesamte Menge an Substitutionen auf jede einzelne der Substitutionen \
aus der Menge angewandt.
expUnification.finalType1=In diesem Schritt wird der zuvor berechnete allgemeinste Unifikator
expUnification.finalType2=auf den Typen
expUnification.finalType3=des eingegebenen Terms angewandt. Das Ergebnis
expUnification.finalType4=ist der finale Type des eingegebenen Terms.
expUnification.infiniteType=Eine Typvariable taucht auf beiden Seiten des hervorgehobenen Constraints auf. \
Da sich hier ein unendlicher Typ ergeben w√ºrde, bricht die Unifikation ab.
expUnification.diffrentTypes=Da die Typen auf den beiden Seiten des hervorgehobenen Constraints nicht √ºbereinstimmen, \
bricht die Unifikation hier ab.
expLetUnification.finalType1=In diesem Schritt wird der zuvor berechnete allgemeinste Unifikator
expLetUnification.finalType2=auf den Typen
expLetUnification.finalType3=der Let-Definition angewandt. Das Ergebnis
expLetUnification.finalType4=ist der finale Typ der Let-Definition.
expLetUnification.typeAss1=In diesem Schritt werden die Typannahmen
expLetUnification.typeAss2=f√ºr die weitere Durchf√ºhrung des Algorithmus berechnet. Im ersten Schritt wird daf√ºr der MGU
expLetUnification.typeAss3=der Let-Teilinferenz auf die aktuelle Menge von Typannahmen angewandt. Die dadurch entstandenen \
Typannahmen werden anschlie√üend der Menge
expLetUnification.typeAss4=hinzugef√ºgt. Im zweiten Schritt wird der Typ der let-Variable
expLetUnification.typeAss5=berechnet. Daf√ºr wird Typabstraktion
expLetUnification.typeAss6=zuerst instanziiert und dann gemeinsam mit der Variable
expLetUnification.typeAss7=als Typannahme der Menge
expLetUnification.typeAss8=hinzugef√ºgt. Bei der Instanziierung werden alle Typvariablen, die frei in
expLetUnification.typeAss9=aber nicht frei in
expLetUnification.typeAss10=vorkommen allquantifiziert.
expLetUnification.letStep1=Die Let-Teilinferenz ist jetzt abgeschlossen. Der Typinferenz-Algorithmus wird mit der um
expLetUnification.letStep2=erweiterten Constraintmenge und den neu berechneten Typannahmen fortgef√ºhrt.
