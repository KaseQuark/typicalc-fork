package edu.kit.typicalc.model.type;

import edu.kit.typicalc.model.TypeVariableFactory;
import edu.kit.typicalc.model.term.VarTerm;

import java.util.*;

/**
 * Models a type abstraction with its type and the type variables bound by the for-all
 * quantifier.
 */
public class TypeAbstraction {

    private final Type type;
    private final SortedSet<TypeVariable> quantifiedVariables;

    /**
     * Initializes a new type abstraction with its type and the type variables bound by
     * the for-all quantifier.
     *
     * @param type                the type of the type abstraction
     * @param quantifiedVariables the type variables bound by the for-all quantifier
     */
    public TypeAbstraction(Type type, Set<TypeVariable> quantifiedVariables) {
        this.type = type;
        this.quantifiedVariables = new TreeSet<>(quantifiedVariables);
    }

    /**
     * Initializes a new type abstraction with its type and no type variables bound by the
     * for-all quantifier.
     *
     * @param type the type of the type abstraction
     */
    public TypeAbstraction(Type type) {
        this.type = type;
        this.quantifiedVariables = new TreeSet<>();
    }

    /**
     * Initializes a new type abstraction with its type and all type variables quantified
     * that occur free in the given type, but not free in the given type assumptions
     *
     * @param type            the type of the type abstraction
     * @param typeAssumptions the type assumptions to consider when quantifying the type variables
     */
    public TypeAbstraction(Type type, Map<VarTerm, TypeAbstraction> typeAssumptions) {
        this.type = type;
        Set<TypeVariable> varsToBeQuantified = type.getFreeTypeVariables();
        typeAssumptions.forEach((variable, abs) -> varsToBeQuantified.removeAll(abs.getFreeTypeVariables()));
        this.quantifiedVariables = new TreeSet<>(varsToBeQuantified);
    }

    /**
     * Instantiates the type abstraction with a new type and returns it. The new type
     * contains new type variables generated by the given type variable factory.
     *
     * @param typeVarFactory the type variable factory used to generate the new type variables
     * @return the new type resulting from the instantiation of the type abstraction
     */
    public Type instantiate(TypeVariableFactory typeVarFactory) {
        Type instantiatedType = this.type;
        for (TypeVariable variable : this.quantifiedVariables) {
            TypeVariable newVariable = typeVarFactory.nextTypeVariable();
            instantiatedType = instantiatedType.substitute(variable, newVariable);
        }
        return instantiatedType;
    }

    /**
     * Indicates whether any type variables are quantified in the type abstraction.
     *
     * @return true if one or more type variables are quantified, false otherwise
     */
    public boolean hasQuantifiedVariables() {
        return !quantifiedVariables.isEmpty();
    }

    /**
     * Returns a list of all type variables that are bound by an for-all quantifier in the
     * type abstraction.
     *
     * @return a list of all quantified type variables
     */
    public Set<TypeVariable> getQuantifiedVariables() {
        return quantifiedVariables;
    }

    /**
     * Returns a set of all free type variables occurring in the type abstraction.
     *
     * @return all free type variables
     */
    public Set<TypeVariable> getFreeTypeVariables() {
        Set<TypeVariable> set = new HashSet<>(this.type.getFreeTypeVariables());
        set.removeAll(this.quantifiedVariables);
        return set;
    }

    /**
     * Getter for the inner type of the type abstraction
     *
     * @return the inner type of the type abstraction
     */
    public Type getInnerType() {
        return type;
    }

    @Override
    public String toString() {
        return "TypeAbstraction{"
                + "type=" + type
                + ", quantifiedVariables=" + Arrays.toString(quantifiedVariables.toArray()) + '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        TypeAbstraction that = (TypeAbstraction) o;
        return Objects.equals(type, that.type) && Objects.equals(quantifiedVariables, that.quantifiedVariables);
    }

    @Override
    public int hashCode() {
        return Objects.hash(type, quantifiedVariables);
    }
}
